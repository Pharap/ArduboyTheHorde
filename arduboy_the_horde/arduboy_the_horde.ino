#include <Arduboy2.h>
#include <LinkedList.h>

Arduboy2 arduboy;

#define CHAR_WIDTH 6
#define CHAR_HEIGHT 8
#define fps 60
#define circle_width 2
#define SPAWN_DIST 20
#define STATUS_BAR 9
#define X_MAX (WIDTH - circle_width - 1)
#define X_MIN circle_width
#define Y_MAX (HEIGHT - circle_width - 1)
#define Y_MIN (circle_width + 1 + STATUS_BAR)

#define BULLET_SPEED 4
#define ENEMY_MIN_SPEED 5 // Lower is faster
#define ENEMY_MAX_SPEED 4

PROGMEM const unsigned char output_map[] = {
0x0F, 0x80, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 
0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x07, 0x80, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 
0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x03, 0x80, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x01, 0x00, 0x3F, 0xF8, 0x3F, 0xFF, 0xFF, 0x80, 
0x00, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 
0x01, 0x80, 0x1F, 0x80, 0x07, 0xFF, 0xFF, 0x80, 
0x00, 0x01, 0x00, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0xA0, 0x0F, 0x00, 0x03, 0xFF, 0xFE, 0x80, 
0x00, 0x01, 0x73, 0xB3, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0xE0, 0x0C, 0x00, 0x00, 0x7F, 0xFF, 0x80, 
0x00, 0x01, 0xF3, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 
0x08, 0xE0, 0x30, 0x07, 0xE0, 0x0F, 0xFD, 0x00, 
0x00, 0x03, 0xF3, 0xF2, 0x3E, 0x1F, 0xFF, 0xFF, 
0x00, 0xC0, 0x20, 0x3F, 0xF8, 0x07, 0xFB, 0x00, 
0x00, 0x03, 0xF3, 0xF1, 0x9C, 0xEF, 0xFF, 0xFF, 
0x00, 0xC0, 0xE0, 0xF8, 0x0F, 0x03, 0xFE, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x99, 0xE7, 0xFF, 0xFF, 
0x00, 0xC1, 0xE3, 0xC3, 0x83, 0x81, 0xFF, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x99, 0xE7, 0xFF, 0xFF, 
0x01, 0xC1, 0xFF, 0x0F, 0xF0, 0x40, 0x7F, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x98, 0x07, 0xFF, 0xFF, 
0x03, 0x80, 0xF0, 0x3F, 0xF8, 0x20, 0x67, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x99, 0xFF, 0xFF, 0xFF, 
0x07, 0x1A, 0xE0, 0xFF, 0xFC, 0x10, 0x2F, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x99, 0xFF, 0xFF, 0xFF, 
0x06, 0x1F, 0xF0, 0x7F, 0xFF, 0x08, 0x1C, 0x00, 
0x00, 0x03, 0xF3, 0xF3, 0x9C, 0xF7, 0xFF, 0xFF, 
0x02, 0x1F, 0xF6, 0x7F, 0xFF, 0x83, 0x10, 0x00, 
0x00, 0x03, 0xE1, 0xE1, 0x0E, 0x0F, 0xFF, 0xFF, 
0x00, 0x1F, 0xFE, 0x3F, 0xFF, 0xC0, 0x00, 0x00, 
0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x1F, 0xFF, 0x3F, 0xFF, 0xE0, 0x00, 0x00, 
0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x0F, 0xFF, 0x0F, 0xFF, 0xE0, 0x00, 0x00, 
0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x02, 0x0F, 0xFF, 0x87, 0xFF, 0xF0, 0x01, 0x80, 
0x1E, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x06, 0x07, 0xFF, 0xC1, 0xFF, 0xE0, 0x07, 0x80, 
0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x06, 0x03, 0xFF, 0xC4, 0x7F, 0x00, 0x0E, 0x01, 
0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0xFF, 
0x06, 0x01, 0xFF, 0xE3, 0x00, 0x01, 0x9C, 0x03, 
0xFF, 0x01, 0x0C, 0x3F, 0xFF, 0xFF, 0xCF, 0xFF, 
0x04, 0x10, 0xFF, 0xF1, 0x80, 0x03, 0xB8, 0x00, 
0xFE, 0x03, 0x9E, 0x7F, 0xFF, 0xFF, 0xCF, 0xFF, 
0x0D, 0x18, 0xFF, 0xF8, 0xE0, 0x07, 0x30, 0x00, 
0x08, 0x07, 0x9E, 0x78, 0x71, 0x3C, 0x4F, 0x0F, 
0x08, 0x18, 0xFF, 0xFC, 0x3F, 0xC6, 0x70, 0x00, 
0x00, 0x0F, 0x9E, 0x73, 0x38, 0xB9, 0x8E, 0x6F, 
0x00, 0x3E, 0x7F, 0xFF, 0x1F, 0xE0, 0x60, 0x00, 
0x00, 0x1F, 0x9E, 0x67, 0x99, 0xF3, 0xCC, 0xE7, 
0x00, 0x3F, 0x7F, 0xFF, 0xC7, 0xE0, 0xC0, 0x00, 
0x00, 0x1F, 0x80, 0x67, 0x99, 0xF3, 0xCC, 0xE7, 
0x00, 0x27, 0x3F, 0xFF, 0xFF, 0xE0, 0x80, 0x00, 
0x00, 0x3F, 0x9E, 0x67, 0x99, 0xF3, 0xCC, 0x07, 
0x00, 0x7F, 0xBF, 0xFF, 0xFF, 0xE0, 0x80, 0x00, 
0x00, 0x3F, 0x9E, 0x67, 0x99, 0xF3, 0xCC, 0xFF, 
0x00, 0x7E, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 
0x00, 0x3F, 0x9E, 0x67, 0x99, 0xF3, 0xCC, 0xFF, 
0x00, 0x7E, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 
0x00, 0x7F, 0x9E, 0x73, 0x39, 0xF9, 0x8E, 0x77, 
0x00, 0xFD, 0xBF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 
0x00, 0x7F, 0x0C, 0x38, 0x70, 0xFC, 0x47, 0x0F, 
0x00, 0xFF, 0xB7, 0xF0, 0x50, 0x80, 0x00, 0x00, 
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x01, 0xFF, 0x67, 0x80, 0x7E, 0x0C, 0x00, 0x00, 
0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x07, 0xFF, 0x4F, 0x00, 0xFF, 0x3C, 0x00, 0x00, 
0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x05, 0xFE, 0x4E, 0x00, 0x3F, 0xFE, 0x00, 0x00, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x05, 0xFE, 0x0C, 0x00, 0x3F, 0xF2, 0x00, 0x01, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x05, 0xFE, 0x18, 0x04, 0x67, 0x77, 0x00, 0x01, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x05, 0x9F, 0x80, 0x02, 0xC4, 0xF5, 0x00, 0x03, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x03, 0xBD, 0x80, 0x03, 0xDD, 0xE5, 0x00, 0x03, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x03, 0xFD, 0xA0, 0x03, 0xDC, 0x44, 0x00, 0x03, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x03, 0xFF, 0xA0, 0x00, 0xFF, 0xD0, 0x00, 0x07, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x01, 0xFF, 0xA0, 0x00, 0x3D, 0xB0, 0x00, 0x07, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0xFF, 0x60, 0x00, 0x0F, 0xF3, 0x00, 0x07, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x01, 0xFF, 0x60, 0x00, 0x03, 0xF3, 0x20, 0x0F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0xFF, 0xC0, 0x00, 0x00, 0x37, 0x60, 0x0F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x7F, 0x80, 0x00, 0x00, 0x07, 0x64, 0x0F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x64, 0x1F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x3F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x0F, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x0F, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x01, 0x9C, 0x00, 0x00, 0x07, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x03, 0x1C, 0x00, 0x00, 0x03, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x27, 0x1C, 0x80, 0x00, 0x01, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x1F, 0x01, 0xC0, 0x00, 0x01, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x1D, 0x73, 0xC8, 0x00, 0x00, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x1E, 0xFB, 0xD8, 0x00, 0x00, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x3E, 0xFF, 0x98, 0x00, 0x00, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x00, 0x00, 0x0E, 0xFF, 0x98, 0x88, 0x00, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x10, 0x00, 0x1F, 0xFF, 0x00, 0x08, 0x00, 0x1F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x18, 0x00, 0x17, 0xBF, 0x60, 0x10, 0x00, 0x0F, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0x10, 0x00, 0x0B, 0xFF, 0xF0, 0x00, 0x00, 0x03, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

String dir = "R";

bool just_pressed = false;
bool lose = false;
int current_text_size = 1;
int menu_index = 0;
uint8_t current_text_color = WHITE;
uint8_t current_background = BLACK;

// Run modes
// 0 - Menu
// 1 - Game
// 2 - Lose
// 3 - SFX
// 4 - Restart game
int mode = 0;

struct Menu;

struct MenuNode {
  String name;
  int mode;
};

// Full Menus
struct Menu {
  String name;
  LinkedList<MenuNode>* list;
  Menu                * parentMenu;
};

class Player {
  public:
    int x = WIDTH / 2;
    int y = HEIGHT / 2;
    int mod = 60 / fps;
    
    int mov_itter = 0;
    int PSPEED = 0; // Lower is faster
    
    int wave = 1;
    int total_shots = 0;
    int kills = 0;
};

class Enemy {
  public:
    int x = 0;
    int y = 0;
    bool dead = false;

    int mov_itter = 0;
    int ENEMY_SPEED = 0;
};

class Shot {
  public:
    int x = 0;
    int y = 0;
    int x_mod = 0;
    int y_mod = 0;
};

// Create lists for storing enemies and shots
LinkedList<Shot> shots = LinkedList<Shot>();
LinkedList<Enemy> enemies = LinkedList<Enemy>();

// Create player
Player player;

// Create main menu
Menu mainMenu;

// Create lose menu
Menu loseMenu;

void drawStatusBar() {
  arduboy.fillRect(0, 0, WIDTH, STATUS_BAR, WHITE);
  
  // Setup text param
  arduboy.setTextSize(1);
  arduboy.setTextColor(BLACK);
  arduboy.setTextBackground(WHITE);
  
  // Draw status bar text
  arduboy.setCursor(1, 1);
  arduboy.print("Wave: " + (String)(player.wave - 1));
  
  arduboy.setCursor(70, 1);
  arduboy.print("Alive: " + (String)enemies.size());
  
  // Return text param to normal
  arduboy.setTextSize(current_text_size);
  arduboy.setTextColor(current_text_color);
  arduboy.setTextBackground(current_background);
}

// Check if enemy hit player
bool checkCollision() {
  for (int i = 0; i < enemies.size(); i++) {
    
    // Calculate distance
    float distance = sqrt(sq(player.x - enemies.get(i).x) + sq(player.y - enemies.get(i).y));
    
    // Check if distance is less than the radius of the player plus the radius of the enemy
    // Player dies if enemy circle touches player circle
    if (distance <= circle_width * 2) {
      lose = true;
      mode = 2;
    }
  }
}


// Spawn enemies for the current wave
void generateWave() {
  for (int i = 0; i < player.wave; i++) {
    Enemy test_enemy;

    int spawn_x = player.x;
    int spawn_y = player.y;

    // Only spawn enemies off screen
    while ((spawn_x > X_MIN) &&
           (spawn_x < X_MAX) &&
           (spawn_y > Y_MIN) &&
           (spawn_y < Y_MAX)){
      spawn_x = random(X_MIN - 5, X_MAX + 5);
      spawn_y = random(X_MIN - 5, X_MAX + 5);
    }

    test_enemy.x = spawn_x;
    test_enemy.y = spawn_y;

    test_enemy.ENEMY_SPEED = random(ENEMY_MAX_SPEED - 1, ENEMY_MIN_SPEED + 1);

    Serial.println("Generating enemy w/ speed: " + (String)test_enemy.ENEMY_SPEED);

    enemies.add(test_enemy);
  }
  player.wave++;
}

// Work enemy movement
void runEnemies() {
  for (int i = 0; i < enemies.size(); i++) {
    if (!enemies.get(i).dead) {
      Enemy enemy;
      enemy.mov_itter = enemies.get(i).mov_itter + 1;
      enemy.x = enemies.get(i).x;
      enemy.y = enemies.get(i).y;
      enemy.ENEMY_SPEED = enemies.get(i).ENEMY_SPEED;

      // Check if time for enemy to move
      if (enemy.mov_itter >= enemy.ENEMY_SPEED) {
        enemy.mov_itter = 0;

        // Move enemy closer to player
        if (enemy.x < player.x)
          enemy.x++;
        if (enemy.x > player.x)
          enemy.x--;

        if (enemy.y < player.y)
          enemy.y++;
        if (enemy.y > player.y)
          enemy.y--;

      }

      enemies.set(i, enemy);
      
      arduboy.drawCircle(enemies.get(i).x, enemies.get(i).y, circle_width, WHITE);
      arduboy.drawCircle(enemies.get(i).x, enemies.get(i).y, circle_width - 1, WHITE);
    }
  }
}

// Function to move shots and check shot collision
void runShots() {
  for (int i = 0; i < shots.size(); i++) {
    
    // Move coordinates based on direction
    Shot shot;
    shot.x = shots.get(i).x + shots.get(i).x_mod;
    shot.y = shots.get(i).y + shots.get(i).y_mod;
    shot.x_mod = shots.get(i).x_mod;
    shot.y_mod = shots.get(i).y_mod;

    shots.set(i, shot);

    // Check if off screen and if it is, remove from list
    if ((shots.get(i).x < X_MIN) ||
        (shots.get(i).x > X_MAX) ||
        (shots.get(i).y < Y_MIN) ||
        (shots.get(i).y > Y_MAX)) {
      shots.remove(i);
      continue;
    }

    // Draw the shot
    arduboy.drawCircle(shots.get(i).x, shots.get(i).y, 0, WHITE);

    // Check enemies
    for (int z = 0; z < enemies.size(); z++) {
      
      // Enemy hit if true
      if ((shots.get(i).x >= enemies.get(z).x - circle_width) && 
          (shots.get(i).x <= enemies.get(z).x + circle_width) &&
          (shots.get(i).y >= enemies.get(z).y - circle_width) &&
          (shots.get(i).y <= enemies.get(z).y + circle_width)) {
        shots.remove(i);
        enemies.get(z).dead = true;
        enemies.remove(z);
        Serial.println("Enemies remaining: " + (String)enemies.size());
        player.kills++;
        continue;
      }
    }
  }
}

// Reset game values
void restartGame() {
  // Remove all enemies
  enemies.clear();
  
  // Reset player values
  player.x = WIDTH / 2;
  player.y = HEIGHT / 2;
  player.mod = 60 / fps;
    
  player.mov_itter = 0;
  player.PSPEED = 0;
  
  player.wave = 1;
  player.total_shots = 0;
  player.kills = 0;
  
  // Start game
  Serial.println("Restart Enemies: " + (String)enemies.size() + " Restart Waves: " + (String)player.wave);
  generateWave();
  
  lose = false;
  mode = 1;
}

// Function to add MenuNodes to a menu
void addNodes(Menu * menu, String name, int mode)
{
  menu->list->add(MenuNode{name, mode});
}

void runMenu(Menu * menu, bool inverted = false) {
  // Iterate through menu items
  for (int i = 0; i < menu->list->size(); i++) {

    // Format text to be printed on screen
    int num_chars = menu->list->get(i).name.length();
    //int x = (WIDTH / 2) - (num_chars * CHAR_WIDTH / 2);
    int x = WIDTH - (num_chars * CHAR_WIDTH) - 5;
    int y = (HEIGHT / 2) - (CHAR_HEIGHT / 2);
    arduboy.setCursor(x, y + (i * CHAR_HEIGHT) + 20);
    if (inverted) {
      arduboy.setTextColor(BLACK);
      arduboy.setTextBackground(WHITE);
    }
    arduboy.print(menu->list->get(i).name);
    arduboy.setTextColor(current_text_color);
    arduboy.setTextBackground(current_background);

    // Draw selector dot next to active menu item
    if (menu_index == i) {
      if (inverted)
        arduboy.drawCircle(x - 5, (y + (i * CHAR_HEIGHT)) + (CHAR_HEIGHT / 2) + 19, 1, BLACK);
      else
        arduboy.drawCircle(x - 5, (y + (i * CHAR_HEIGHT)) + (CHAR_HEIGHT / 2) + 19, 1, WHITE);
    }
  }

  // Cycle Down menu index
  if (arduboy.justPressed(UP_BUTTON)) {
    menu_index--;
    if (menu_index <= 0)
      menu_index = 0;
    Serial.println("menu_index: " + (String)menu_index);
  }

  // Cycle Up menu index
  if (arduboy.justPressed(DOWN_BUTTON)) {
    menu_index++;
    if (menu_index >= menu->list->size() - 1)
      menu_index = menu->list->size() - 1;
    Serial.println("menu_index: " + (String)menu_index);
  }

  // Menu item is selected
  if (arduboy.justPressed(B_BUTTON)) {
    mode = menu->list->get(menu_index).mode;
    menu_index = 0;
  }
}

void setup() {
  Serial.begin(115200);

  // Setup menus
  mainMenu.list = new LinkedList<MenuNode>();
  loseMenu.list = new LinkedList<MenuNode>();

  mainMenu.name = "Main Menu";
  loseMenu.name = "Lose Menu";

  // Populate menus with menu options
  mainMenu.parentMenu = NULL;
  addNodes(&mainMenu, "Start", 4);
  addNodes(&mainMenu, "SFX", 3);

  loseMenu.parentMenu = NULL;
  addNodes(&loseMenu, "Play Again", 4);
  addNodes(&loseMenu, "Main Menu", 0);
  
  arduboy.begin();
  arduboy.initRandomSeed();
  arduboy.setFrameRate(fps);
  arduboy.drawCircle(player.x, player.y, circle_width, WHITE);
  arduboy.display();

  generateWave();
}

void loop() {
  if (!(arduboy.nextFrame()))
    return;

  arduboy.pollButtons();

  // This does not scale well
  // Main Menu
  if (mode == 0) {
    arduboy.clear();
    arduboy.drawSlowXYBitmap(0,0,output_map,128,64,1);
    runMenu(&mainMenu, true);
  }

  // Play game
  else if ((!lose) && (mode == 1)) {
    // Shoot
    if (arduboy.pressed(B_BUTTON)) {
      if (!just_pressed) {
        just_pressed = true;
        player.total_shots++;
  
        Shot shot;
        
        if (dir == "R") {
          shot.x = player.x;
          shot.y = player.y;
          shot.x_mod = BULLET_SPEED;
          shot.y_mod = 0;
          shots.add(shot);
        }
        else if (dir == "L") {
          shot.x = player.x;
          shot.y = player.y;
          shot.x_mod = -BULLET_SPEED;
          shot.y_mod = 0;
          shots.add(shot);
        }
        else if (dir == "U") {
          shot.x = player.x;
          shot.y = player.y;
          shot.x_mod = 0;
          shot.y_mod = -BULLET_SPEED;
          shots.add(shot);
        }
        else if (dir == "D") {
          shot.x = player.x;
          shot.y = player.y;
          shot.x_mod = 0;
          shot.y_mod = BULLET_SPEED;
          shots.add(shot);
        }
      }
    }
    else
      just_pressed = false;
  
    // Sprint
    if (arduboy.pressed(A_BUTTON))
      player.mod = (60 / fps) * 2;
    else
      player.mod = 60 / fps;
      
    player.mov_itter++;
  
    // Right
    if ((arduboy.pressed(RIGHT_BUTTON)) && (player.x < X_MAX) && (player.mov_itter >= player.PSPEED)) {
      player.mov_itter = 0;
      dir = "R";
      if (player.x + (1 * player.mod) < X_MAX)
        player.x = player.x + (1 * player.mod);
      else
        player.x++;
    }
  
    // Left
    if ((arduboy.pressed(LEFT_BUTTON)) && (player.x > X_MIN) && (player.mov_itter >= player.PSPEED)) {
      player.mov_itter = 0;
      dir = "L";
      if (player.x - (1 * player.mod) > X_MIN)
        player.x = player.x - (1 * player.mod);
      else
        player.x--;
    }
  
    // UP
    if ((arduboy.pressed(UP_BUTTON)) && (player.y > Y_MIN) && (player.mov_itter >= player.PSPEED)) {
      player.mov_itter = 0;
      dir = "U";
      if (player.y - (1 * player.mod) > Y_MIN)
        player.y = player.y - (1 * player.mod);
      else
        player.y--;
    }
  
    // Down
    if ((arduboy.pressed(DOWN_BUTTON)) && (player.y < Y_MAX) && (player.mov_itter >= player.PSPEED)) {
      player.mov_itter = 0;
      dir = "D";
      if (player.y + (1 * player.mod) < Y_MAX)
        player.y = player.y + (1 * player.mod);
      else
        player.y++;
    }
  
    // Create new wave if all enemies defeated
    if (enemies.size() <= 0) {
      generateWave();
    }
  
    arduboy.clear();
  
    // Draw the player
    arduboy.drawCircle(player.x, player.y, circle_width, WHITE);
  
    // Draw enemies
    runEnemies();
  
    runShots();
  
    checkCollision();
    
    drawStatusBar();
  }

  // Lose Menu
  else if (mode == 2){
    arduboy.clear();

    arduboy.println("You Died");
    arduboy.println("Waves Survived: " + (String)player.wave);
    arduboy.println("Kills: " + (String)player.kills);
    arduboy.println("Accuracy: " + (String)(((float)player.kills * 100.0) / (float)player.total_shots) + "%");

    runMenu(&loseMenu);
    
    // Restart ?
    //if (arduboy.pressed(B_BUTTON)) {
    //  restartGame();
    //}
  }

  else if (mode == 4)
    restartGame();

  arduboy.display();

}
